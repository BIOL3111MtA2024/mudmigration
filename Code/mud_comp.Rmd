---
title: "Mud Migration Community Compositon"
output: html_notebook
author:
  Paige Stuart
  Douglass Campbell
---
# Install packages if needed
```{r install_packages}
#install.packages("googlesheets4")
#install.packages("googledrive")
#install.packages("tidyverse")
```

# Load packages
```{r load_packages}
library(googlesheets4)
library(googledrive)
library(tidyverse)
```

# Connect to google account
De-authorize Google account to allow universal access to the raw data sheet.Then retrieve data sheet from where it's stored on google drive.
```{r connect_google}
gs4_deauth()
googlesheet_url <- "https://docs.google.com/spreadsheets/d/1Ga0qnVxOVR9NwSNI5RM1iz1L2MoCAyF0O4x3D6mCePw/edit?gid=405129858#gid=405129858"
```

# Accessing sheets
Access each of the three sheets on the spreadsheet.
```{r accessing_sheets}
#Accessing sheet with meta data
community_composition <- read_sheet(googlesheet_url, sheet = "community_composition") 
#Accessing sheet with raw data 
raw_cell_measurements <- read_sheet(googlesheet_url, sheet = "raw_cell_measurements") 
#Accessing data dictionary for reference to column values
data_dictionary <- read_sheet(googlesheet_url, sheet = "data_dictionary")
```
# Set Up
Initial steps for setting up the raw data for analysis. 

## Set missing values of width_1 and width_2
Some width measurements are blank if a) the cell was undefined or b) the morphology had no unequal widths. This corrects these missing values to 1 um, which is the smallest measurement possible. 
```{r missing_widths}
#Correcting width 1
corrected_width_data <- raw_cell_measurements |>
  mutate(Width1_um = case_when(
    is.na(Width1_um) ~ 1,
    TRUE ~ Width1_um
  ))
#Correcting width 2
corrected_width_data <- corrected_width_data |>
  mutate(Width2_um = case_when(is.na(Width2_um) ~ Width1_um,
                               !is.na(Width2_um) ~ Width2_um
  ))
```

## List of morphotypes obseved 
Before graphing anything with morphotypes check for any misspelled variables.
```{r unqiue_morphotypes}
unique_morphotypes <- unique(corrected_width_data$CellMorphotype)
print(unique_morphotypes)
```

## Correct mispelled pennate
A single morphotype label was misspelled this corrected it.
```{r correct_mispelling}
#Find cell containing the misspelled word
mislabel_pennate <- which(corrected_width_data  == "penate", arr.ind = TRUE)
mislabel_pennate

#Indicate the cell which was mislabeled
corrected_width_data[106, "CellMorphotype"] <- "pennate"
```

## Fix missing CellVol
One cell did not fit well into any of the volume calculations. New morphotype created for it. 
```{r fix_missing}
#Rename morphotype to better calculate cell volume
corrected_width_data[12, "CellMorphotype"] <- "other"
```

## Estimate volumes & maximum linear dimension
Data set created with new columns for calculated volume and dimension. Each morphotype is uniquely shaped and therefore the volume is calculated differently depending. Maximum dimension is defined as the largest number wether width 1 or 2 or the length measurement. 
```{r volumes_dimension}
#Calculate Cell Volume for each Morphotype
volume_dimension_data <- corrected_width_data |>
  mutate(CellVol = case_when(CellMorphotype == "centric" ~ pi * (Width1_um/2)^2 *  Width2_um,
                          CellMorphotype == "pennate" ~  Length_um * Width1_um * Width2_um,
                          CellMorphotype == "undefined" ~ 4/3 * pi * (Length_um/2)^3,
                          CellMorphotype == "peanut" ~   Length_um * Width1_um * Width2_um,
                          CellMorphotype == "rectangular" ~ Length_um * Width1_um * Width2_um,
                          CellMorphotype == "square"~ Width1_um^2 * Width2_um,
                          CellMorphotype == "other" ~ 4/3 * pi * (Width1_um/2)^3
  )
  )

#Calculate Maximum Dimension
volume_dimension_data <- volume_dimension_data |>
  rowwise() |>
  mutate(MaxDim_um = max(Length_um, Width1_um, Width2_um, na.rm = TRUE)
  )
```

## Check for missing results
This code finds empty cells in the data set. 
```{r missing_results}
#Find empty cells in CellVol
#empty_CellVol <- which(is.na(volume_dimension_data$CellVol))
#volume_dimension_data[empty_CellVol, ]

#Find it's location
#empty_CellVol_location <- cbind(row = empty_CellVol, column = "CellVol")
#empty_CellVol_location

#Find empty cells in MaxDim_um
#empty_MaxDim <- which(is.na(volume_dimension_data$MaxDim_um))
#volume_dimension_data[empty_MaxDim, ]

#Corrected these missing results, return to misspelling above ^
```

## Control for chain sizes
Accounting for centric chains a new column was created for total volume and maximum dimension. This multiplies cell volume and dimension by the number of cells in every chain. For this to work a column in the raw data was filled with either 1 for single cells or the number of cells in a chain.
```{r size_chain}
volume_dimension_data <- volume_dimension_data %>%
  mutate(CellVol_Total = CellVol * ChainNum) %>%
  mutate(MaxDim_Total = MaxDim_um * ChainNum)
```

## Histogram of max dimension
A histogram was created to visualize cell size to get a better sense of the data. 
```{r histogram}
#Plot Maximum Dimensions
volume_dimension_data |>
  ggplot()+
  geom_histogram(aes(MaxDim_Total))
```

## Merge corrected data to metadata
This merges the new data frame corrected above to the metadata about each sample.
```{r merge_sheets}
merged_data <- merge(community_composition, volume_dimension_data, by = "SamplePhotoID", all.x = TRUE)
```

# Cell Count Analysis

## Create bargraph to visualize cell counts per sample
A bargraph was used as reference for furture sample visualizations. A plot of 'SamplePhotoId' versus the number of cells observed per single image was created. With only one image per bar the area is set to 0.16mm2. 
```{r bargraph_sample}
# #Summarize data with chain number
# merged_data_cell_count <- merged_data %>%
#   group_by(Light, Temp_C, Top_Bottom, SamplePhotoID) %>%
#   summarize(CellCount = sum(ChainNum), .groups = "drop")
# 
# #Create bar graph
# ggplot(merged_data_cell_count, aes(x = SamplePhotoID, y = CellCount)) +
#   geom_bar(stat = "identity", fill = "purple") +
#   labs(x = "Sample", y = "Number of Cells per 0.16mm2", title = "Number of Cells per Sample") +
#   theme_minimal() +
#   theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

## Filter data for ONLY centric and pennate morphotypes and then group. 
Filtered data for only the morphotypes of focus, pennate and centric. These were chosen because of their observational frequency. Further, group by patch, light, temperature, layer, morphotype, chain number, and maximum dimension.  
```{r filtered_data}
 #Summarize the counts for each maximum dimension bin per condition
filtered_data <- merged_data |>
  dplyr::filter(CellMorphotype %in% c("pennate", "centric")) |>
  mutate(MorphoSize = case_when(CellMorphotype == "pennate" & MaxDim_Total <= 50 ~ "PennateSmall", 
                                CellMorphotype == "pennate" & MaxDim_Total > 50 ~ "PennateLarge",
                                CellMorphotype == "centric" & MaxDim_Total <= 50 ~ "CentricSmall", 
                                CellMorphotype == "centric" & MaxDim_Total > 50 ~ "CentricLarge"))


  #dplyr::group_by(Patch, Light, Temp_C, Top_Bottom, CellMorphotype, ChainNum, MaxDim_Total)

#print(filtered_data)
```

## Reorder top and bottom
Ordered the filtered data to make top layer samples first and then all bottom layers. This insures that all top layer samples are displayed on the higher chunk of every graph.  
```{r reorder_top_bottom}
filtered_data$Top_Bottom <- factor(filtered_data$Top_Bottom, levels = c("top", "bottom"))
filtered_data$Light <- factor(filtered_data$Light, levels = c("light", "med", "dark"))
```

# Cell count per maximum dimension and condition
Created a histogram of the filtered data with maximum dimension in um and a generated cell count per facet of top and bottom layers and temperature. Medium light conditions were excluded. Light was included as fill. The generated cell count is per 0.32 mm2 which accounts for the area of two 0.16mm2 images per sample.  
```{r count_dimension}
filtered_data |>
  filter(Light != "med") |>
  ggplot() +
  geom_histogram(aes(x = MaxDim_Total, fill = Light), breaks = c(0, 50, 100, 150), color = "black", position = "stack") +
  labs(
    x = "Maximum Dimension (um)", 
    y = "Cell Count per 0.32 mmÂ²", 
    title = str_wrap("Total cell count vs. maximum dimension, faceted by temperature and layer, light level displayed by colour")
  ) +
  facet_grid(rows = vars(Light, Top_Bottom), cols = vars(Temp_C)) + 
  scale_fill_brewer(palette = "Set1") + 
  theme_minimal() +
  theme(
    plot.title = element_text(size = 14, hjust = 0.5),
    axis.text.x = element_text(angle = 45, hjust = 1), 
    axis.title.x = element_text(size = 12),
    strip.text.y = element_text(size = 12), 
    strip.text.x = element_text(size = 14), 
    legend.position = "bottom", 
    strip.text = element_blank() 
  )
```

# Cell count per condition 
Created a new data set that groups entries based on light, temperature, lens paper layer, and SampleID. Then a summarized function created a cell count based on ChainNum. This is graphed using ggplot per patch (= corresponding top and bottom) and per light and temperature with cell count of the y-axis. Cell counts are per 0.32 mm2 because two images were taken per sample each with an area of 0.16 mm2. 
```{r cell_count}
cell_count_data <- filtered_data %>%
  group_by(Light, Temp_C, Top_Bottom, SampleID) %>%
  summarize(CellCount = sum(ChainNum), .groups = "drop")

ggplot(cell_count_data, aes(x = Light, y = CellCount, fill = Light)) +
  geom_bar(stat = "identity") +
  labs( 
       y = "Cell Count per Image (0.32 mm2)", 
       title = "Cell Count per Condition") +
  facet_grid(rows = vars(Top_Bottom), cols = vars(Temp_C)) +
  theme_minimal() +
  theme(    
    axis.text.x = element_blank(),  
    axis.title.x = element_blank(),  
    plot.title = element_text(size = 12, hjust = 0.5),
    #legend.position = "bottom" 
  )
```

# Top-bottom ratio graph per patch and condition
A new data set was created which first removed the medium light condition then filtered for top before bottom. Then the data was grouped by patch, layer, light, temperature, and morphology with size considered. A cell count was made by summing the chain numbers. The top to bottom ratio was calculated by dividing the cell count for every condition, top divided by bottom. Next, a plot was created with patches of corresponding top and bottom lenses on the x-axis and ratio on the y-axis. Light was used as a fill. 
```{r top_bottom_ratio}
# Ratio of Top and Bottom counts within each Patch
top_bottom_ratio_data <- filtered_data |>
  filter(Light != "med") |>
  dplyr::filter(Top_Bottom %in% c("top", "bottom")) |> 
  dplyr::group_by(Patch, Top_Bottom, Light, Temp_C, MorphoSize) |> 
  dplyr::summarize(Total_Count = sum(ChainNum), .groups = "drop") |> 
  tidyr::pivot_wider(names_from = Top_Bottom, values_from = Total_Count, values_fill = 0) |>
  dplyr::mutate(Ratio = top / bottom)

#Plot patch by ratio
ggplot(top_bottom_ratio_data, aes(x = Patch, y = Ratio, fill = Light)) +
  geom_bar(stat = "identity", position = "dodge") +
  labs(
    x = "Patch (Corresponding Top and Bottom Samples)", 
    y = "Top-to-Bottom Ratio of Cell Counts per 0.32 mm2",
    title = str_wrap("Top-to-bottom ratio of cell count, faceted by temperature and light.")
  ) +
  facet_grid(~ Temp_C) + 
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1),
    plot.title = element_text(size = 12, hjust = 0.5)
  )
```

# Top-bottom ratio per condition, sorted by cell morphotype and size category
A plot was created to visualize the cell count ratio between top and bottom layers per light and temperature condition. Morphology per size was highlighted with centric and pennate being assigned either small or big. Small meaning that the cell was under or equal to 50 um and large for any cell over 50 um. 
```{r}
ggplot(top_bottom_ratio_data, aes(x = MorphoSize, y = Ratio, fill = MorphoSize)) +
  geom_bar(stat = "identity", position = "dodge") +
  labs(
    y = "Top-to-Bottom Ratio of Cell Counts per 0.32 mm2",
    title = str_wrap("Top-to-bottom ratio of cell count, faceted by temperature and light, morphotype sorted by size shown through colour.")
  ) +
  facet_grid(~ Light ~ Temp_C) + 
  scale_fill_discrete(name = "Morphotype by Size") +
  theme_minimal() +
  theme(
    axis.text.x = element_blank(),  
    axis.title.x = element_blank(),  
    plot.title = element_text(size = 12, hjust = 0.5),
    legend.position = "bottom", 
  )
```






















