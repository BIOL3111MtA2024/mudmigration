---
title: "Mud Migration Community Compositon"
output: html_notebook
author:
  Paige Stuart
  Douglass Campbell
---
# Install packages if needed
```{r install_packages}
#install.packages("googlesheets4")
#install.packages("googledrive")
#install.packages("tidyverse")
```

# Load packages
```{r load_packages}
library(googlesheets4)
library(googledrive)
library(tidyverse)
```

# Connect to google account
De-authorize Google account to allow universal access to the raw data sheet.Then retrieve data sheet from where it's stored on google drive.
```{r connect_google}
gs4_deauth()
googlesheet_url <- "https://docs.google.com/spreadsheets/d/1Ga0qnVxOVR9NwSNI5RM1iz1L2MoCAyF0O4x3D6mCePw/edit?gid=405129858#gid=405129858"
```

# Accessing sheets
Access each of the three sheets on the spreadsheet.
```{r accessing_sheets}
#Accessing sheet with meta data
community_composition <- read_sheet(googlesheet_url, sheet = "community_composition") 
#Accessing sheet with raw data 
raw_cell_measurements <- read_sheet(googlesheet_url, sheet = "raw_cell_measurements") 
#Accessing data dictionary for reference to column values
data_dictionary <- read_sheet(googlesheet_url, sheet = "data_dictionary")
```
# Set Up
Initial steps for setting up the raw data for analysis. 

## Set missing values of width_1 and width_2
Some width measurements are blank if a) the cell was undefined or b) the morphology had no unequal widths. This corrects these missing values to 1 um, which is the smallest measurement possible. 
```{r missing_widths}
#Correcting width 1
corrected_width_data <- raw_cell_measurements |>
  mutate(Width1_um = case_when(
    is.na(Width1_um) ~ 1,
    TRUE ~ Width1_um
  ))
#Correcting width 2
corrected_width_data <- corrected_width_data |>
  mutate(Width2_um = case_when(is.na(Width2_um) ~ Width1_um,
                               !is.na(Width2_um) ~ Width2_um
  ))
```

## List of morphotypes obseved 
Before graphing anything with morphotypes check for any misspelled variables.
```{r unqiue_morphotypes}
unique_morphotypes <- unique(corrected_width_data$CellMorphotype)
print(unique_morphotypes)
```

## Correct mispelled pennate
A single morphotype label was misspelled this corrects it.
```{r correct_mispelling}
#Find cell containing the misspelled word
mislabel_pennate <- which(corrected_width_data  == "penate", arr.ind = TRUE)
mislabel_pennate

#Indicate the cell which was mislabeled
corrected_width_data[106, "CellMorphotype"] <- "pennate"
```

## Fix missing CellVol
One cell did not fit well into any of the volume calculations. Therefore, a new morphotype category was created for it. 
```{r fix_missing}
#Rename morphotype to better calculate cell volume
corrected_width_data[12, "CellMorphotype"] <- "other"
```

## Estimate volumes & maximum linear dimension
ADD DISCRIPTION OF CALCULATION!
```{r volumes_dimension}
#Calculate Cell Volume for each Morphotype
volume_dimension_data <- corrected_width_data |>
  mutate(CellVol = case_when(CellMorphotype == "centric" ~ pi * (Width1_um/2)^2 *  Width2_um,
                          CellMorphotype == "pennate" ~  Length_um * Width1_um * Width2_um,
                          CellMorphotype == "undefined" ~ 4/3 * pi * (Length_um/2)^3, 
                          CellMorphotype == "peanut" ~   Length_um * Width1_um * Width2_um,
                          CellMorphotype == "rectangular" ~ Length_um * Width1_um * Width2_um,
                          CellMorphotype == "square"~ Width1_um^2 * Width2_um, 
                          CellMorphotype == "other" ~ 4/3 * pi * (Width1_um/2)^3
  )
  )

#Calculate Maximum Dimension
volume_dimension_data <- volume_dimension_data |>
  rowwise() |>
  mutate(MaxDim_um = max(Length_um, Width1_um, Width2_um, na.rm = TRUE)
  )
```

## Check for missing results
This code finds empty cells in the data set. 
```{r missing_results}
#Find empty cells in CellVol
#empty_CellVol <- which(is.na(volume_dimension_data$CellVol))
#volume_dimension_data[empty_CellVol, ]

#Find it's location
#empty_CellVol_location <- cbind(row = empty_CellVol, column = "CellVol")
#empty_CellVol_location

#Find empty cells in MaxDim_um
#empty_MaxDim <- which(is.na(volume_dimension_data$MaxDim_um))
#volume_dimension_data[empty_MaxDim, ]

#Corrected these missing results, return to misspelling above ^
```

## Control for chain sizes
NEED DISCRIPTION - DELETE VOLUME?
This conversion works because, chains all centric
```{r size_chain}
volume_dimension_data <- volume_dimension_data %>%
  mutate(CellVol_Total = CellVol * ChainNum) %>%
  mutate(MaxDim_Total = MaxDim_um * ChainNum)
```

## Histogram of max dimension
A histogram was created to visualise cell size to get a better idea of the data. 
```{r histogram}
#Plot Maximum Dimensions
volume_dimension_data |>
  ggplot()+
  geom_histogram(aes(MaxDim_Total))
```

## Merge corrected data to metadata
This merges the new data frame corrected above to the metadata about each sample.
```{r merge_sheets}
merged_data <- merge(community_composition, volume_dimension_data, by = "SamplePhotoID", all.x = TRUE)
```

# Cell Count Analysis

## Create bargraph to visualize cell counts per sample
DESCRIPTIONS ADDED UP TO THIS POINT 
```{r bargraph_sample}
# #Summarize data with chain number
# merged_data_cell_count <- merged_data %>%
#   group_by(Light, Temp_C, Top_Bottom, SamplePhotoID) %>%
#   summarize(CellCount = sum(ChainNum), .groups = "drop")
# 
# #Create bar graph
# ggplot(merged_data_cell_count, aes(x = SamplePhotoID, y = CellCount)) +
#   geom_bar(stat = "identity", fill = "purple") +
#   labs(x = "Sample", y = "Number of Cells per 0.16mm2", title = "Number of Cells per Sample") +
#   theme_minimal() +
#   theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

## Filter data for ONLY centric and pennate morphotypes and then group. 
Filtered data for only the morphotypes of focus, pennate and centric. These were chosen because of their observational frequency. Further, group by patch, light, temperature, layer, morphotype, chain number, and maximum dimension.  
```{r filtered_data}
 #Summarize the counts for each maximum dimension bin per condition
filtered_data <- merged_data |>
  dplyr::filter(CellMorphotype %in% c("pennate", "centric")) |>
  dplyr::group_by(Patch, Light, Temp_C, Top_Bottom, CellMorphotype, ChainNum, MaxDim_Total)

#print(filtered_data)
```

## Reorder top and bottom
Ordered the filtered data to make top layer samples first and then all bottom layers. This insures that all top layer samples are displayed on the higher chunk of every graph.  
```{r reorder_top_bottom}
filtered_data$Top_Bottom <- factor(filtered_data$Top_Bottom, levels = c("top", "bottom"))
```

# Cell count per maximum dimension and condition
Created a histogram of the filtered data with maximum dimension in um and a generated cell count per facet of top and bottom layers and temperature. Light was included as fill. The generated cell count is per 0.32 mm2 which accounts for the area of two 0.16mm2 images per sample.  
```{r count_dimension}
filtered_data |>
  ggplot() +
  geom_histogram(aes(x = MaxDim_Total, fill = Light), bins = 30, color = "black", position = "stack") +
  labs(
    x = "Maximum Dimension (um)", 
    y = "Cell Count per 0.32 mmÂ²", 
    title = "Total Cell Count per Condition and Maximum Dimension"
  ) +
  facet_grid(rows = vars(Top_Bottom), cols = vars(Temp_C)) + 
  scale_fill_brewer(palette = "Set1") + 
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1), 
    axis.title.x = element_text(size = 12),
    strip.text.y = element_text(size = 12), 
    strip.text.x = element_text(size = 14), 
    legend.position = "bottom", 
    strip.text = element_blank() 
  )
```

# Cell count per condition 
Created a new data set that groups entries based on light, temperature, lens paper layer, and SampleID. Then a summarized function created a cell count based on ChainNum. This is graphed using ggplot per patch (= corresponding top and bottom) and per light and temperature with cell count of the y-axis. Cell counts are per 0.32 mm2 because two images were taken per sample each with an area of 0.16 mm2. 
```{r cell_count}
cell_count_data <- filtered_data %>%
  group_by(Light, Temp_C, Top_Bottom, SampleID) %>%
  summarize(CellCount = sum(ChainNum), .groups = "drop")

ggplot(cell_count_data, aes(x = Light, y = CellCount, fill = Light)) +
  geom_bar(stat = "identity") +
  labs(x = "Patch (Corresponding Top and Bottom Samples)", 
       y = "Cell Count per Image (0.32 mm2)", 
       title = "Cell Count per Condition") +
  facet_grid(rows = vars(Top_Bottom), cols = vars(Temp_C)) +
  theme_minimal() +
  theme(axis.text.x = element_blank(),  
        axis.title.x = element_text(size = 12))  
```

# Top-bottom ratio graph per patch and condition
ASK DR.C ABOUT RATIO CALCULATION
```{r top_bottom_ratio}
# Ratio of Top and Bottom counts within each Patch
top_bottom_ratio_data <- filtered_data |>
  dplyr::filter(Top_Bottom %in% c("top", "bottom")) |> 
  dplyr::group_by(Patch, Top_Bottom, Light, Temp_C, CellMorphotype) |> 
  dplyr::summarize(Total_Count = sum(ChainNum), .groups = "drop") |> 
  tidyr::pivot_wider(names_from = Top_Bottom, values_from = Total_Count, values_fill = 0) |>
  dplyr::mutate(Ratio = top / bottom)
  #dplyr::mutate(Ratio = bottom / top)

ggplot(top_bottom_ratio_data, aes(x = Patch, y = Ratio, fill = Light)) +
  geom_bar(stat = "identity", position = "dodge") +
  labs(
    x = "Patch (Corresponding Top and Bottom Samples)", 
    y = "Top-to-Bottom Ratio of Cell Counts per 0.32 mm2",
    title = "Top-to-Bottom Ratio with Temperature and Light Conditions"
  ) +
  facet_grid(~ Temp_C) + 
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1)
  )
```

# IN PROGRESS 
```{r}
ggplot(top_bottom_ratio_data, aes(x = Patch, y = Ratio, fill = CellMorphotype)) +
  geom_bar(stat = "identity", position = "dodge") +
  labs(
    x = "Patch (Corresponding Top and Bottom Samples)", 
    y = "Top-to-Bottom Ratio of Cell Counts per 0.32 mm2",
    title = "Top-to-Bottom Ratio with Temperature and Light Conditions"
  ) +
  facet_grid(~ Temp_C ~ Light) + 
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1)
  )
```






















